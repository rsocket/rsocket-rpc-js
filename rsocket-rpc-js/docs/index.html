<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">Home</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src">core/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/RequestHandlingRSocket.js~RequestHandlingRSocket.html">RequestHandlingRSocket</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/RpcClient.js~RpcClient.html">RpcClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/SwitchTransformOperator.js~SwitchTransformOperator.html">SwitchTransformOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ClientConfig">ClientConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-DuplexConnection">DuplexConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Encodable">Encodable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Flowable">Flowable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Payload">Payload</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PayloadSerializers">PayloadSerializers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ReactiveSocket">ReactiveSocket</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Responder">Responder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Serializer">Serializer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Setup">Setup</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Single">Single</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/rsocket/rsocket-js/blob/master/packages/rsocket-types/src/ReactiveStreamTypes.js">ISubscription</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#frames-src">frames/src</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-encodeMetadata">encodeMetadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getMetadata">getMetadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getMethod">getMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getService">getService</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTracing">getTracing</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getVersion">getVersion</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-METHOD_LENGTH_SIZE">METHOD_LENGTH_SIZE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SERVICE_LENGTH_SIZE">SERVICE_LENGTH_SIZE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TRACING_LENGTH_SIZE">TRACING_LENGTH_SIZE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VERSION">VERSION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VERSION_SIZE">VERSION_SIZE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Buffer">Buffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BufferEncoder">BufferEncoder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Encoder">Encoder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-UTF8Encoder">UTF8Encoder</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#metrics-src">metrics/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/BaseMeter.js~BaseMeter.html">BaseMeter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/Counter.js~Counter.html">Counter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/Histogram.js~Histogram.html">Histogram</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/Metrics.js~Metrics.html">Metrics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/MetricsExporter.js~MetricsExporter.html">MetricsExporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/MetricsSubscriber.js~MetricsSubscriber.html">MetricsSubscriber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/RawMeterTag.js~RawMeterTag.html">RawMeterTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/SimpleMeterRegistry.js~SimpleMeterRegistry.html">SimpleMeterRegistry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/Timer.js~Timer.html">Timer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-embedMetricsSingleSubscriber">embedMetricsSingleSubscriber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_PERCENTILES">DEFAULT_PERCENTILES</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#metrics-src-stats">metrics/src/stats</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/stats/ExponentiallyDecayingSample.js~ExponentiallyDecayingSample.html">ExponentiallyDecayingSample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/stats/ExponentiallyWeightedMovingAverage.js~EWMA.html">EWMA</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/stats/Sample.js~Sample.html">Sample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/metrics/src/stats/UniformSample.js~UniformSample.html">UniformSample</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#tracing-src">tracing/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/tracing/src/SpanSubscriber.js~SpanSubscriber.html">SpanSubscriber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSpanSingle">createSpanSingle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-bufferToMap">bufferToMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deserializeTraceData">deserializeTraceData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mapToBuffer">mapToBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-trace">trace</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-traceAsChild">traceAsChild</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-traceSingle">traceSingle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-traceSingleAsChild">traceSingleAsChild</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="rsocket-javascript-rpc">RSocket JavaScript RPC</h1><p><a href="https://travis-ci.org/netifi/rsocket-rpc"><img src="https://travis-ci.org/netifi/rsocket-rpc.svg?branch=master"></a></p>
<h2 id="documentation">Documentation</h2><h3 id="core">Core</h3><p>The primary class/entry point for the core package is the RpcClient. The client encapsulates the RSocket methods of <code>fireAndForget</code>, <code>requestResponse</code>, <code>requestStream</code>, and <code>requestChannel</code> and merges them with a bidirectional connection, allowing seamless use of RSocket for RPC.</p>
<p>The input config has this flow-type signature</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">ClientConfig&lt;D, M&gt; = {|
  serializers?: PayloadSerializers&lt;D, M&gt;,
  setup: {|
    keepAlive: number,
    lifetime: number,
    metadata?: Encodable,
  |},
  transport: DuplexConnection,
  responder?: Responder&lt;D, M&gt;,
|}</code>
</code></pre>
<p>Serializers and responder are optional. If the client doesn&apos;t intend to receive traffic, there is no need to add a responder. Responder is a type alias for the RSocket API.</p>
<p>The transport can be any implementation of a DuplexConnection, a common one being WebSockets.</p>
<p>RpcClient&apos;s <code>connect(): Single&lt;ReactiveSocket&lt;D, M&gt;&gt;</code> method starts the asynchronous process of obtaining a handle to an open RSocket connection and moving through additional business logic.</p>
<p>Here is an example instantiation of an RpcClient</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">  const local = &apos;ws://localhost:8088/&apos;;
  const keepAlive = 60000 /* 60s in ms */;
  const lifetime = 360000 /* 360s in ms */;
  const transport = new RSocketWebsocketClient({url:local}, BufferEncoders);
  const client = new RpcClient({setup:{keepAlive, lifetime}, transport});
  client.connect().subscribe({
    onComplete: rsocket =&gt; {
      console.info(&quot;Success! We have a handle to an RSocket connection&quot;);
    },
    onError: error =&gt; {
      console.error(&quot;Failed to connect to local RSocket server.&quot;, error);
    }
  });</code>
</code></pre>
<h3 id="frames">Frames</h3><p>The Frames package provides methods for encoding and reading Payload metadata</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">encodeMetadata(
  service: string,
  method: string,
  tracing: Encodable,
  metadata: Encodable,
): Buffer</code>
</code></pre>
<p>Clients are encouraged to use the <code>encodeMetadata</code> method to send well defined call-routing metadata with their Payloads. On the receiving end, the call router can use the other helper methods to route the call and capture/propagate tracing information.</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">getVersion(buffer: Buffer): number</code>
</code></pre>
<pre><code><code class="source-code prettyprint">getService(buffer: Buffer): string</code>
</code></pre><pre><code><code class="source-code prettyprint">getMethod(buffer: Buffer): string</code>
</code></pre><pre><code><code class="source-code prettyprint">getTracing(buffer: Buffer): Buffer</code>
</code></pre><h3 id="tracing">Tracing</h3><p>RSocket RPC provides helpers to inject Open Tracing implementations via helper methods.</p>
<pre><code><code class="source-code prettyprint">trace&lt;T&gt;(
  tracer?: Tracer,
  name?: String,
  ...tags: Object
): Object =&gt; (Flowable&lt;T&gt;) =&gt; Flowable&lt;T&gt;</code>
</code></pre><p>Trace takes an Open Tracing <code>Tracer</code>, an operation name, and optional tags. The result is a function that allows propagation of a SpanContext map through a Flowable. One can pass a collection of tags in the form of a map/Object and have it woven through a Flowable =&gt; Flowable function. Here&apos;s an example</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">const traceCapture = trace(myTracer, &quot;myOperation&quot;, {tag1: &quot;value&quot;}, {tag2: &quot;another value&quot;});

... more code ...

const subscriberTransformer = traceCapture({additionalTag1: 1, additionalTag2: &quot;two&quot;});

subscriberTransformer(rsocket.requestStream(serviceRequest))
.subscribe({
    ...
});</code>
</code></pre>
<p>This wraps our default tags <code>tag1</code> and <code>tag2</code>, further picks up <code>additonalTag1</code> and <code>additionalTag2</code> as we progress through our business logic.</p>
<p>We then pass that the resulting <code>Flowable</code> from doing a <code>requestStream</code> and the Tracer will capture tracing events from the Stream.</p>
<pre><code><code class="source-code prettyprint">traceAsChild&lt;T&gt;(
  tracer?: Tracer,
  name?: String,
  ...tags: Object
): SpanContext =&gt; (Flowable&lt;T&gt;) =&gt; Flowable&lt;T&gt;</code>
</code></pre><p>This method is the same as above except intended to be used on the server side where a SpanContext has been passed from a client. The helper method below to <code>deserializeTraceData</code> should be used on the Payload metadata to extract the starter SpanContext</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">const traceCapture = traceAsChild(myTracer, &quot;myServerOperation&quot;, {serverTag1: &quot;value&quot;}, {serverTag2: &quot;another value&quot;});

const subscriberTransformer = traceCapture(deserializeTraceData(myTracer, requestMetadata));

return subscriberTransformer(serviceImpl.requestStream(serviceRequest));</code>
</code></pre>
<p>Below are equivalent methods for <code>Single</code> types, meaning really <code>requestReply</code>.</p>
<pre><code><code class="source-code prettyprint">traceSingle&lt;T&gt;(
  tracer?: Tracer,
  name?: String,
  ...tags: Object
): Object =&gt; (Single&lt;T&gt;) =&gt; Single&lt;T&gt; </code>
</code></pre><pre><code class="lang-angular2html"><code class="source-code prettyprint">traceSingleAsChild&lt;T&gt;(
  tracer?: Tracer,
  name?: String,
  ...tags: Object
): SpanContext =&gt; (Single&lt;T&gt;) =&gt; Single&lt;T&gt;</code>
</code></pre>
<p>These last three are helper methods to make it easier to propagate tracing context.</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">deserializeTraceData(tracer, metadata) : SpanContext</code>
</code></pre>
<pre><code><code class="source-code prettyprint">mapToBuffer(map: Object): Buffer </code>
</code></pre><pre><code><code class="source-code prettyprint">bufferToMap(buffer: Buffer): Object</code>
</code></pre><h3 id="metrics">Metrics</h3><h4 id="protobuf-file">Protobuf File</h4><p>Unlike the other packages, Metrics is much more sensitive to interoperability and/or doesn&apos;t have an open standard like Open Tracing on which to hang its hat. As such, we include a protobuf file that defines the structure of metrics data and required services. This is found in <code>metrics/idl/proto/metrics.proto</code></p>
<p>To build the relevant types from source, run <code>yarn install &amp;&amp; yarn protoc</code></p>
<h4 id="basic-use">Basic Use</h4><p>The Metrics package exports a few helper methods that will wrap timing metrics automatically around streams.</p>
<pre><code><code class="source-code prettyprint"> timed&lt;T&gt;(
    registry?: IMeterRegistry,
    name: string,
    ...tags: Object[]
  ): (Flowable&lt;T&gt;) =&gt; Flowable&lt;T&gt;</code>
</code></pre><pre><code class="lang-angular2html"><code class="source-code prettyprint"> timedSingle&lt;T&gt;(
    registry?: IMeterRegistry,
    name: string,
    ...tags: Object[]
  ): (Single&lt;T&gt;) =&gt; Single&lt;T&gt;</code>
</code></pre>
<p>Similar to the Tracing package, these functions return a wrapping function, through which a user weaves their RSocket calls</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">  const metricsWrapper = timed(myMeterRegistry, &quot;my.function.name&quot;, {tag1: &quot;tag&quot;}, {anotherTag: &quot;again&quot;});
  const responseStream = rsocket.requestStream(requestPayload);
  metricsWrapper(responseStream).subscribe(...);</code>
</code></pre>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">  const metricsWrapper = timedSingle(myMeterRegistry, &quot;my.function.name&quot;, {tag1: &quot;tag&quot;}, {anotherTag: &quot;again&quot;});
  const responseFuture = rsocket.requestResponse(requestPayload);
  metricsWrapper(responseFuture).subscribe(...);</code>
</code></pre>
<p>Both functions take a IMeterRegistry which has flow-type</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">interface IMeterRegistry {
  registerMeter(meter: IMeter): void;
  registerMeters(meters: IMeter[]): void;
  meters(): IMeter[];
}</code>
</code></pre>
<p>This essentially represents any container class that can store handles to Meters and deliver them as a collection. The Package includes a default implementation in <code>SimpleMeterRegistry</code>.</p>
<h4 id="meters">Meters</h4><p>The Metrics package provides 2 implementations of IMeter: <code>Counter</code> and <code>Timer</code>. They both implement this interface:</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">interface IMeter {
  name: string;
  description: ?string;
  statistic: string;
  type: string;
  tags: RawMeterTag[];
  units?: string;
  rates(): Object;
  convert(converter: (IMeter) =&gt; Meter[]): Meter[];
}</code>
</code></pre>
<p>The <code>timed</code> helper methods automatically wrap timing and counting metrics around significant <code>Flowable</code> and <code>Single</code> events. Additional metrics may be added ad hoc and registered with the IMeterRegistry.</p>
<h4 id="exporting-metrics">Exporting Metrics</h4><p>Should the user also have an RSocket based Metrics sink, we provide an RSocket native metrics source in <code>MetricsExporter</code>.</p>
<p>The <code>MetricsExporter</code> constructor has these inputs</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">MetricsExporter{

  constructor(
    handler: MetricsSnapshotHandlerClient,
    registry: IMeterRegistry,
    exportPeriodSeconds: number,
    batchSize: number,
  ),

  start(), // Open channel and begin sending metrics

  stop() // Stop sending metrics

}</code>
</code></pre>
<p>The <code>MetricsSnapshotHandlerClient</code> is defined in the metrics protobuf file. It has one method of note</p>
<pre><code><code class="source-code prettyprint">rpc StreamMetrics (stream MetricsSnapshot) returns (stream Skew)</code>
</code></pre><p>Meaning we open a channel and push <code>MetricsSnapshot</code>s and receive time <code>Skew</code>s from the server as it notices our clocks are out of sync. The <code>MetricsExporter</code> takes this as a metrics sink, the <code>IMeterRegistry</code> as the metrics source, and the windowing parameters in the time period or batch size.</p>
<h3 id="tying-it-all-together">Tying It All Together</h3><p>Assume we have an RSocket server that supports WebSockets on <code>localhost</code>. We have an RSocket-based service client called MyServiceClient. We want to capture tracing and metrics data. In real code, we would likely encapsulate that within the MyServiceClient, but for demonstration purposes we will make everything very explicit.</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">const {RequestHandlingRSocket,
       RpcClient} = require(&apos;rsocket-rpc-core&apos;);
const Tracing = require(&apos;rsocket-rpc-tracing&apos;);
const {Metrics,
       SimpleMeterRegistry, 
       MetricsExporter, 
       MetricsSnapshotHandlerClient} = require(&apos;rsocket-rpc-metrics&apos;);

// Create our Open Tracing tracer for use later
const myTracer = new MyCompliantTracer();

// Connection info for our RSocket Client
const local = &apos;ws://localhost:8088/&apos;;
const keepAlive = 60000 /* 60s in ms */;
const lifetime = 360000 /* 360s in ms */;
const transport = new RSocketWebsocketClient({url:local}, BufferEncoders);
const responder = new RequestHandlingRSocket(); // Will address this at the end
const rsocketClient = new RpcClient({setup:{keepAlive, lifetime}, transport, responder});

// We need a few references declared ahead of an rsocket being available 
const meters = new SimpleMeterRegistry();
let snapshotClient = null; // Will initialize shortly
let metricsExporter = null; // Will initialize shortly

let myServiceClient = null; // Will initialize shortly

rsocketClient.connect().subscribe({
    onComplete: rsocket =&gt; {
      myServiceClient = new MyServiceClient(rsocket);

      snapshotClient = new MetricsSnapshotHandlerClient(rsocket);
      metricsExporter = new MetricsExporter(snapshotClient, meters, 60 /*seconds*/, 1024 /*metrics count*/);
      metricsExporter.start();
    },
    onError: error =&gt; {
      console.error(&quot;Failed to connect to local RSocket server.&quot;, error);
    }
});


... Later in our business logic ...

// Set up our traced, metrics-captured calls
const streamMetricsWrapper = Metrics.timed(meters, &quot;myService.dataStream&quot;, {timezone: &quot;GMT-7&quot;});
const requestResponseMetricsWrapper = Metrics.timedSingle(meters, &quot;myService.fetchDatum&quot;, {timezone: &quot;GMT-7&quot;});

const streamTracing = Tracing.trace(myTracer, &quot;myService.dataStream&quot;, {clientType: &quot;Chrome Browser&quot;});
const requestResponseTracing = Tracing.trace.Single(myTracer, &quot;myService.fetchDatum&quot;, {clientType: &quot;Chrome Browser&quot;});

... Later still, our User does something of interest ...


const tracingTags = {uiContextId: 12345, focusedItem: 9876};

const tracedTimedRequestResponse = requestResponseTracing(tracingTags) // We&apos;ve closed over the tracing tags, now Single =&gt; Single
(requestResponseMetricsWrapper( //This wrapper&apos;s signature is Single =&gt; Single
        myServiceClient.fetchDatum(new DatumRequest()) // This method returns a Single
    ) // We&apos;ve now wrapped the original call in metrics
); // We&apos;ve now wrapped the metrics-captured call in tracing

tracedTimedRequestResponse.subscribe({
    // Issues the request and do our business logic onComplete
});

// And we would do the same for a streaming method

const tracedTimedStream = streamTracing(tracingTags) // We&apos;ve closed over the tracing tags, now Flowable =&gt; Flowable
(streamMetricsWrapper( //This wrapper&apos;s signature is Flowable =&gt; Flowable
        myServiceClient.dataStream(new StreamRequest()) // This method returns a Flowable
    ) // We&apos;ve now wrapped the original call in metrics
); // We&apos;ve now wrapped the metrics-captured call in tracing

tracedTimedStream.subscribe({
    // Issues the request and do our business logic onNext/onComplete
});
</code>
</code></pre>
<h4 id="wiring-up-the-responder">Wiring up the Responder</h4><p>At the beginning, we added a canned Responder class from the Core package, <code>RequestHandlingRSocket</code>. It takes for granted that callers are using the Metadata helpers to package metadata about the service calls in question.</p>
<p>Its relevant method is</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">addService(service: string, handler: Responder&lt;Buffer, Buffer&gt;)</code>
</code></pre>
<p>Aside from this, it implements (and delegates) the RSocket methods to handling services. Responder is an alias for this that implies that it will have those methods invoked by a remote caller rather than act as a local caller to a remote callee.</p>
<p>In our example, let&apos;s add a responder to our client that provides a method for a remote caller to inject config updates.</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">
const configUpdater = {
    fireAndForget: function(){
        //Not supported but has no expected return
    },
    requestStream: function(payload){
        return Flowable.error(&quot;requestStream is not supported&quot;);
    },
    requestChannel: function(payloads){
        return Flowable.error(&quot;requestStream is not supported&quot;);
    },
    requestResponse: function(payload){
        const newConfig = deserializeConfig(payload.data);
        // apply new config;
        return Single.of(&quot;OK&quot;);
    }
}

responder.addService(&quot;example.rsocket.configUpdater&quot;, configUpdater);</code>
</code></pre>
<p>And now our RpcClient will also respond to requests from the server to update its configuration that are directed to the service &quot;example.rsocket.configUpdater&quot;.</p>
<p>We can also add tracing and metrics here though again, in Production code this would all be encapsulated in service/client implementations but for demo purposes we&apos;re doing it inline and explicitly.</p>
<pre><code class="lang-angular2html"><code class="source-code prettyprint">const serviceMetricsWrapper = Metrics.timedSingle(meters, &quot;myClient.updateConfig&quot;, {timezone: &quot;GMT-7&quot;});

const serviceTracing = Tracing.traceSingleAsChild(myTracer, &quot;myClient.updateConfig&quot;, {clientType: &quot;Chrome Browser&quot;});

const configUpdater = {
    fireAndForget: function(){
        //Not supported but has no expected return
    },
    requestStream: function(payload){
        return Flowable.error(&quot;requestStream is not supported&quot;);
    },
    requestChannel: function(payloads){
        return Flowable.error(&quot;requestStream is not supported&quot;);
    },
    requestResponse: function(payload){
        const spanContext = Tracing.deserializeTraceData(myTracer, payload.metadata);
        return serviceTracing(spanContext) // We&apos;ve closed over the tracing span context, now Single =&gt; Single
        (serviceMetricsWrapper( //This wrapper&apos;s signature is Single =&gt; Single
                new Single(subscriber =&gt; {
                    subscriber.onSubscribe();
                    const newConfig = deserializeConfig(payload.data);                    
                    // apply new config;
                    subscriber.onComplete(&quot;OK&quot;);
                })
            ) // We&apos;ve now wrapped the original call in metrics
        );
    }
}</code>
</code></pre>
<p>Let&apos;s break this down because it&apos;s hard to follow at first.</p>
<ul>
<li>We are extracting the span context from the caller, if any, with the <code>deserializeTraceData</code> method</li>
<li>We feed this into the <code>traceSingleAsChild</code> method which captures the span context and will weave it through a <code>Single</code> (its signature is Single =&gt; Single)</li>
<li>We further use the Metrics wrapping method <code>timedSingle</code> to weave timing and count metrics through a <code>Single</code> (signature also Single =&gt; Single))</li>
<li>And finally, we create a new Single inline that has the same logic as before, only it waits for a subscriber (meaning call to <code>subscribe</code>) to do anything so that we can start our metrics timing and trace on-demand from the caller.</li>
</ul>
<p>And with that, we have an RpcClient that can make and serve instrumented calls over the same RSocket.</p>
<h2 id="bugs-and-feedback">Bugs and Feedback</h2><p>For bugs, questions, and discussions please use the <a href="https://github.com/netifi/rsocket-rpc/issues">Github Issues</a>.</p>
<h2 id="license">License</h2><p>Copyright 2017 Netifi Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
